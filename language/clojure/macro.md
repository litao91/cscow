# Macro
Clojure evaluates all the arguments before passing them to a function.
That's why we need macro.

The use of macro:
```clojure
(defmacro name doc-string? attr-map? [params*] body)
```
Macros provide a layer of indirection so that you can automate the common
parts of any recurring pattern.

## Expanding Macros
Consider the follow:
```clojure
(defmacro unless [expr form]
  (list 'if expr nil form))
```
* By quoting `'if`, you prevent Clojure from directly evaluating `if` at
  macro expansion time. Instead, evaluation strips of the quote, leaving
  `if` to be compiled.
* You do not want to quote `expr` and `form`, because they are macro
  arguments, Clojure will substitute them without evaluation at macro
  expansion time.
* You do not quote `nil` since `nil` evaluates to itself.

The function `macroexpand-1` will should you what happens at macro
expansion time:
```clojure
(macroexpand-1 form)
```

## Syntax Quote, Unquote, and Splicing Unquote
Clojure macros support **templating wihtout introducing a separate
language**.

Unquote work like this:
```clojure
(defmacro chain [x form]
  `(. ~x ~form))
```

*splicing unquote*: `~@`, splice into a list, so no parentheses

Many macros follow the pattern:

1. Begin macro body with a syntax quote \`  to the entirethign as a
   template
* Insert individual arguments with an unquote (`~`)
* Splice in `more` areguments with splicing unquote (`~@`)

## Creating Names in macro
The expanded version we want:
```clojure
(let [start (System/nanoTime)
  result (str "a" "b")]
  {result result :elapsed (- (System/nanoTime) start)})
```

This don't work
```clojure
(defmacro bench [expr]
  `(let [start (System/nanoTime)
         result ~expr]
     {:result result :elapsed (- (System/nanoTime) start)}))
```
Because you are trying to `let` a qualified name.

When a syntax-quote form encounters a symbol, it resolves the symbol to a
fully qualified name. This protects you from a nasty macro bug called
*symbol capture*

Clojure provides a reader form for creating unique local names. Inside a
syntax-quoted form, you can append a `#` to an unqualified name, and
Clojure will create an autogenerated symbol, or *auto-gensym:*

```clojure
(defmacro bench [expr]
  `(let [start# (System/nanoTime)
         reuslt# ~expr]
     {:result result# :elapsed (- (System/namoTime) start#)}))
```

## Creating Vars
Clojure vars are created by the `def` special form. Anything else that
creates a var must eventually call def. So `defn`, `defmacro` and
`defmulti` are all themselves macros

Low-level function for creating structs called `create-struct`
```clojure
(create-struct & key-symbols)
```



